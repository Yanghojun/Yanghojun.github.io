---
title: KITTI 데이터셋 튜토리얼
date: 2023-08-11
categories: [AI 연구개발자로의 길, 데이터 분석]
tags: [Kitti, Odometry, Image-Projection, Homogeneous, Rectification]
math: true
---

> 참고할 블로그  
> [Rectification 관련 설명](http://www.ntrexgo.com/archives/2280)  
> [KITTI 분석 - 다크프로그래머](https://darkpgmr.tistory.com/190)  
> [KITTI VISUAL Odometry 기초 설명](https://snacky.tistory.com/96)    
> [KITTI VISUAL Odometry 코드로 완전 상세 분석](https://github.com/FoamoftheSea/KITTI_visual_odometry/blob/main/KITTI_visual_odometry.ipynb)  
> [위 상세분석 코드와 연관된 youtube](https://www.youtube.com/watch?v=pRD8JI8oi3w&list=PLrHDCRerOaI9HfgZDbiEncG5dx7S3Nz6X&index=4)  



## 시각화

![Alt text](/images/image-67.png)
<div align="center" markdown="1">
왼쪽부터 3D 원본, xy 평면에 투영, xy 평면에 투영하고 z값으로 색 입히기, yz 평면에 투영, yz 평면에 투영하고 x값으로 색 입히기
</div>



## 의문
1. 다음은 000003.txt에 들어있는 캘리브레이션 정보이다.

    ```txt
    P0: 7.215377000000e+02 0.000000000000e+00 6.095593000000e+02 0.000000000000e+00 0.000000000000e+00 7.215377000000e+02 1.728540000000e+02 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.000000000000e+00 0.000000000000e+00
    P1: 7.215377000000e+02 0.000000000000e+00 6.095593000000e+02 -3.875744000000e+02 0.000000000000e+00 7.215377000000e+02 1.728540000000e+02 0.000000000000e+00 0.000000000000e+00 0.000000000000e+00 1.000000000000e+00 0.000000000000e+00
    P2: 7.215377000000e+02 0.000000000000e+00 6.095593000000e+02 4.485728000000e+01 0.000000000000e+00 7.215377000000e+02 1.728540000000e+02 2.163791000000e-01 0.000000000000e+00 0.000000000000e+00 1.000000000000e+00 2.745884000000e-03
    P3: 7.215377000000e+02 0.000000000000e+00 6.095593000000e+02 -3.395242000000e+02 0.000000000000e+00 7.215377000000e+02 1.728540000000e+02 2.199936000000e+00 0.000000000000e+00 0.000000000000e+00 1.000000000000e+00 2.729905000000e-03
    R0_rect: 9.999239000000e-01 9.837760000000e-03 -7.445048000000e-03 -9.869795000000e-03 9.999421000000e-01 -4.278459000000e-03 7.402527000000e-03 4.351614000000e-03 9.999631000000e-01
    Tr_velo_to_cam: 7.533745000000e-03 -9.999714000000e-01 -6.166020000000e-04 -4.069766000000e-03 1.480249000000e-02 7.280733000000e-04 -9.998902000000e-01 -7.631618000000e-02 9.998621000000e-01 7.523790000000e-03 1.480755000000e-02 -2.717806000000e-01
    Tr_imu_to_velo: 9.999976000000e-01 7.553071000000e-04 -2.035826000000e-03 -8.086759000000e-01 -7.854027000000e-04 9.998898000000e-01 -1.482298000000e-02 3.195559000000e-01 2.024406000000e-03 1.482454000000e-02 9.998881000000e-01 -7.997231000000e-01
    ```

    이 캘리브레이션 정보는 라이다 좌표계 -> 카메라 좌표계로 변경해주는 것이고 포인트의 x, y, z는 라이다에서 나온다. `Tr_velo_to_cam`이 그래서 필요한 것으로 이해가 되는데, `Tr_imu_to_velo`는 왜 있는것인지?   IMU 센서값을 따로 쓰는곳이 있는가?

2. `Tr_velo_to_cam`을 적용하면 라이다 좌표에서 나온 x, y, z가 카메라 좌표계로 변경된다. 그럼 카메라 좌표계 -> 이미지 좌표계로 변경하면 끝인것이니 내부 파라미터 $$ K $$ 만 행렬곱하면 되지 않는가? 왜 위 1번 의문의 Projection matrix인
$$ K\left[ \begin{matrix} R | T \end{matrix} \right] $$ 
꼴로 외부 파라미터까지 곱해지는 걸까?

    - 카메라 좌표계 -> 월드 좌표계로 변환하는 것이기 때문이다. 왜 월드 좌표계로 변환해주는게 필요할까? 월드 좌표계가 있어야, t1, t2로 서로 다른 위치에서(예를 들어, 라이다를 탑재한 차량이 조금 움직인 것) 서로 다른 시간에 찍은 라이다 센서값이 같아도, **월드 좌표계로 인해 두 위치는 달라진다.**

